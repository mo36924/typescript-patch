diff --git a/node_modules/typescript/lib/tsc.js b/node_modules/typescript/lib/tsc.js
index be83dff..09ee1fb 100644
--- a/node_modules/typescript/lib/tsc.js
+++ b/node_modules/typescript/lib/tsc.js
@@ -56667,13 +56667,37 @@ var ts;
         function getEffectiveCallArguments(node) {
             if (node.kind === 205) {
                 var template = node.template;
-                var args_3 = [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())];
-                if (template.kind === 218) {
+                if (template.kind === 14 /* NoSubstitutionTemplateLiteral */){
+                    var arrayType = createTupleType([getLiteralType(template.text)], undefined, true);
+                    var rawType = createTupleType([getLiteralType(template.rawText)], undefined, true);
+                    var attributesTable = ts.createSymbolTable();
+                    var attributeSymbol = createSymbol(4 /* Property */, "raw", 8 /* Readonly */);
+                    attributeSymbol.type = rawType;
+                    attributesTable.set("raw", attributeSymbol);
+                    var objectType = createAnonymousType(undefined, attributesTable, ts.emptyArray, ts.emptyArray, undefined, undefined);
+                    var stringsType = getIntersectionType([arrayType, objectType]);
+                    return [createSyntheticExpression(template, stringsType)];
+                } else if (template.kind === 218 /* TemplateExpression */) {
+                    var texts = [getLiteralType(template.head.text)];
+                    var rawTexts = [getLiteralType(template.head.rawText)];
+                    var args = [];
                     ts.forEach(template.templateSpans, function (span) {
-                        args_3.push(span.expression);
+                        texts.push(getLiteralType(span.literal.text));
+                        rawTexts.push(getLiteralType(span.literal.rawText));
+                        args.push(span.expression);
                     });
-                }
-                return args_3;
+                    var arrayType = createTupleType(texts, undefined, true);
+                    var rawType = createTupleType(rawTexts, undefined, true);
+                    var attributesTable = ts.createSymbolTable();
+                    var attributeSymbol = createSymbol(4 /* Property */, "raw", 8 /* Readonly */);
+                    attributeSymbol.type = rawType;
+                    attributesTable.set("raw", attributeSymbol);
+                    var objectType = createAnonymousType(undefined, attributesTable, ts.emptyArray, ts.emptyArray, undefined, undefined);
+                    var stringsType = getIntersectionType([arrayType, objectType]);
+                    args.unshift(createSyntheticExpression(template, stringsType));
+                    return args;
+                }
+                return [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())];
             }
             if (node.kind === 161) {
                 return getEffectiveDecoratorArguments(node);
diff --git a/node_modules/typescript/lib/tsserver.js b/node_modules/typescript/lib/tsserver.js
index a2b627f..776985d 100644
--- a/node_modules/typescript/lib/tsserver.js
+++ b/node_modules/typescript/lib/tsserver.js
@@ -67944,13 +67944,37 @@ var ts;
         function getEffectiveCallArguments(node) {
             if (node.kind === 205 /* TaggedTemplateExpression */) {
                 var template = node.template;
-                var args_3 = [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())];
-                if (template.kind === 218 /* TemplateExpression */) {
+                if (template.kind === 14 /* NoSubstitutionTemplateLiteral */){
+                    var arrayType = createTupleType([getLiteralType(template.text)], undefined, true);
+                    var rawType = createTupleType([getLiteralType(template.rawText)], undefined, true);
+                    var attributesTable = ts.createSymbolTable();
+                    var attributeSymbol = createSymbol(4 /* Property */, "raw", 8 /* Readonly */);
+                    attributeSymbol.type = rawType;
+                    attributesTable.set("raw", attributeSymbol);
+                    var objectType = createAnonymousType(undefined, attributesTable, ts.emptyArray, ts.emptyArray, undefined, undefined);
+                    var stringsType = getIntersectionType([arrayType, objectType]);
+                    return [createSyntheticExpression(template, stringsType)];
+                } else if (template.kind === 218 /* TemplateExpression */) {
+                    var texts = [getLiteralType(template.head.text)];
+                    var rawTexts = [getLiteralType(template.head.rawText)];
+                    var args = [];
                     ts.forEach(template.templateSpans, function (span) {
-                        args_3.push(span.expression);
+                        texts.push(getLiteralType(span.literal.text));
+                        rawTexts.push(getLiteralType(span.literal.rawText));
+                        args.push(span.expression);
                     });
-                }
-                return args_3;
+                    var arrayType = createTupleType(texts, undefined, true);
+                    var rawType = createTupleType(rawTexts, undefined, true);
+                    var attributesTable = ts.createSymbolTable();
+                    var attributeSymbol = createSymbol(4 /* Property */, "raw", 8 /* Readonly */);
+                    attributeSymbol.type = rawType;
+                    attributesTable.set("raw", attributeSymbol);
+                    var objectType = createAnonymousType(undefined, attributesTable, ts.emptyArray, ts.emptyArray, undefined, undefined);
+                    var stringsType = getIntersectionType([arrayType, objectType]);
+                    args.unshift(createSyntheticExpression(template, stringsType));
+                    return args;
+                }
+                return [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())];
             }
             if (node.kind === 161 /* Decorator */) {
                 return getEffectiveDecoratorArguments(node);
diff --git a/node_modules/typescript/lib/tsserverlibrary.js b/node_modules/typescript/lib/tsserverlibrary.js
index 4800656..2bfda98 100644
--- a/node_modules/typescript/lib/tsserverlibrary.js
+++ b/node_modules/typescript/lib/tsserverlibrary.js
@@ -68138,13 +68138,37 @@ var ts;
         function getEffectiveCallArguments(node) {
             if (node.kind === 205 /* TaggedTemplateExpression */) {
                 var template = node.template;
-                var args_3 = [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())];
-                if (template.kind === 218 /* TemplateExpression */) {
+                if (template.kind === 14 /* NoSubstitutionTemplateLiteral */){
+                    var arrayType = createTupleType([getLiteralType(template.text)], undefined, true);
+                    var rawType = createTupleType([getLiteralType(template.rawText)], undefined, true);
+                    var attributesTable = ts.createSymbolTable();
+                    var attributeSymbol = createSymbol(4 /* Property */, "raw", 8 /* Readonly */);
+                    attributeSymbol.type = rawType;
+                    attributesTable.set("raw", attributeSymbol);
+                    var objectType = createAnonymousType(undefined, attributesTable, ts.emptyArray, ts.emptyArray, undefined, undefined);
+                    var stringsType = getIntersectionType([arrayType, objectType]);
+                    return [createSyntheticExpression(template, stringsType)];
+                } else if (template.kind === 218 /* TemplateExpression */) {
+                    var texts = [getLiteralType(template.head.text)];
+                    var rawTexts = [getLiteralType(template.head.rawText)];
+                    var args = [];
                     ts.forEach(template.templateSpans, function (span) {
-                        args_3.push(span.expression);
+                        texts.push(getLiteralType(span.literal.text));
+                        rawTexts.push(getLiteralType(span.literal.rawText));
+                        args.push(span.expression);
                     });
-                }
-                return args_3;
+                    var arrayType = createTupleType(texts, undefined, true);
+                    var rawType = createTupleType(rawTexts, undefined, true);
+                    var attributesTable = ts.createSymbolTable();
+                    var attributeSymbol = createSymbol(4 /* Property */, "raw", 8 /* Readonly */);
+                    attributeSymbol.type = rawType;
+                    attributesTable.set("raw", attributeSymbol);
+                    var objectType = createAnonymousType(undefined, attributesTable, ts.emptyArray, ts.emptyArray, undefined, undefined);
+                    var stringsType = getIntersectionType([arrayType, objectType]);
+                    args.unshift(createSyntheticExpression(template, stringsType));
+                    return args;
+                }
+                return [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())];
             }
             if (node.kind === 161 /* Decorator */) {
                 return getEffectiveDecoratorArguments(node);
diff --git a/node_modules/typescript/lib/typescript.js b/node_modules/typescript/lib/typescript.js
index a3c7e07..7405f2c 100644
--- a/node_modules/typescript/lib/typescript.js
+++ b/node_modules/typescript/lib/typescript.js
@@ -68138,13 +68138,37 @@ var ts;
         function getEffectiveCallArguments(node) {
             if (node.kind === 205 /* TaggedTemplateExpression */) {
                 var template = node.template;
-                var args_3 = [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())];
-                if (template.kind === 218 /* TemplateExpression */) {
+                if (template.kind === 14 /* NoSubstitutionTemplateLiteral */){
+                    var arrayType = createTupleType([getLiteralType(template.text)], undefined, true);
+                    var rawType = createTupleType([getLiteralType(template.rawText)], undefined, true);
+                    var attributesTable = ts.createSymbolTable();
+                    var attributeSymbol = createSymbol(4 /* Property */, "raw", 8 /* Readonly */);
+                    attributeSymbol.type = rawType;
+                    attributesTable.set("raw", attributeSymbol);
+                    var objectType = createAnonymousType(undefined, attributesTable, ts.emptyArray, ts.emptyArray, undefined, undefined);
+                    var stringsType = getIntersectionType([arrayType, objectType]);
+                    return [createSyntheticExpression(template, stringsType)];
+                } else if (template.kind === 218 /* TemplateExpression */) {
+                    var texts = [getLiteralType(template.head.text)];
+                    var rawTexts = [getLiteralType(template.head.rawText)];
+                    var args = [];
                     ts.forEach(template.templateSpans, function (span) {
-                        args_3.push(span.expression);
+                        texts.push(getLiteralType(span.literal.text));
+                        rawTexts.push(getLiteralType(span.literal.rawText));
+                        args.push(span.expression);
                     });
-                }
-                return args_3;
+                    var arrayType = createTupleType(texts, undefined, true);
+                    var rawType = createTupleType(rawTexts, undefined, true);
+                    var attributesTable = ts.createSymbolTable();
+                    var attributeSymbol = createSymbol(4 /* Property */, "raw", 8 /* Readonly */);
+                    attributeSymbol.type = rawType;
+                    attributesTable.set("raw", attributeSymbol);
+                    var objectType = createAnonymousType(undefined, attributesTable, ts.emptyArray, ts.emptyArray, undefined, undefined);
+                    var stringsType = getIntersectionType([arrayType, objectType]);
+                    args.unshift(createSyntheticExpression(template, stringsType));
+                    return args;
+                }
+                return [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())];
             }
             if (node.kind === 161 /* Decorator */) {
                 return getEffectiveDecoratorArguments(node);
diff --git a/node_modules/typescript/lib/typescriptServices.js b/node_modules/typescript/lib/typescriptServices.js
index 71ac581..6299973 100644
--- a/node_modules/typescript/lib/typescriptServices.js
+++ b/node_modules/typescript/lib/typescriptServices.js
@@ -68138,13 +68138,37 @@ var ts;
         function getEffectiveCallArguments(node) {
             if (node.kind === 205 /* TaggedTemplateExpression */) {
                 var template = node.template;
-                var args_3 = [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())];
-                if (template.kind === 218 /* TemplateExpression */) {
+                if (template.kind === 14 /* NoSubstitutionTemplateLiteral */){
+                    var arrayType = createTupleType([getLiteralType(template.text)], undefined, true);
+                    var rawType = createTupleType([getLiteralType(template.rawText)], undefined, true);
+                    var attributesTable = ts.createSymbolTable();
+                    var attributeSymbol = createSymbol(4 /* Property */, "raw", 8 /* Readonly */);
+                    attributeSymbol.type = rawType;
+                    attributesTable.set("raw", attributeSymbol);
+                    var objectType = createAnonymousType(undefined, attributesTable, ts.emptyArray, ts.emptyArray, undefined, undefined);
+                    var stringsType = getIntersectionType([arrayType, objectType]);
+                    return [createSyntheticExpression(template, stringsType)];
+                } else if (template.kind === 218 /* TemplateExpression */) {
+                    var texts = [getLiteralType(template.head.text)];
+                    var rawTexts = [getLiteralType(template.head.rawText)];
+                    var args = [];
                     ts.forEach(template.templateSpans, function (span) {
-                        args_3.push(span.expression);
+                        texts.push(getLiteralType(span.literal.text));
+                        rawTexts.push(getLiteralType(span.literal.rawText));
+                        args.push(span.expression);
                     });
-                }
-                return args_3;
+                    var arrayType = createTupleType(texts, undefined, true);
+                    var rawType = createTupleType(rawTexts, undefined, true);
+                    var attributesTable = ts.createSymbolTable();
+                    var attributeSymbol = createSymbol(4 /* Property */, "raw", 8 /* Readonly */);
+                    attributeSymbol.type = rawType;
+                    attributesTable.set("raw", attributeSymbol);
+                    var objectType = createAnonymousType(undefined, attributesTable, ts.emptyArray, ts.emptyArray, undefined, undefined);
+                    var stringsType = getIntersectionType([arrayType, objectType]);
+                    args.unshift(createSyntheticExpression(template, stringsType));
+                    return args;
+                }
+                return [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())];
             }
             if (node.kind === 161 /* Decorator */) {
                 return getEffectiveDecoratorArguments(node);
diff --git a/node_modules/typescript/lib/typingsInstaller.js b/node_modules/typescript/lib/typingsInstaller.js
index 34fd6f2..bb5bc81 100644
--- a/node_modules/typescript/lib/typingsInstaller.js
+++ b/node_modules/typescript/lib/typingsInstaller.js
@@ -67933,13 +67933,37 @@ var ts;
         function getEffectiveCallArguments(node) {
             if (node.kind === 205 /* TaggedTemplateExpression */) {
                 var template = node.template;
-                var args_3 = [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())];
-                if (template.kind === 218 /* TemplateExpression */) {
+                if (template.kind === 14 /* NoSubstitutionTemplateLiteral */){
+                    var arrayType = createTupleType([getLiteralType(template.text)], undefined, true);
+                    var rawType = createTupleType([getLiteralType(template.rawText)], undefined, true);
+                    var attributesTable = ts.createSymbolTable();
+                    var attributeSymbol = createSymbol(4 /* Property */, "raw", 8 /* Readonly */);
+                    attributeSymbol.type = rawType;
+                    attributesTable.set("raw", attributeSymbol);
+                    var objectType = createAnonymousType(undefined, attributesTable, ts.emptyArray, ts.emptyArray, undefined, undefined);
+                    var stringsType = getIntersectionType([arrayType, objectType]);
+                    return [createSyntheticExpression(template, stringsType)];
+                } else if (template.kind === 218 /* TemplateExpression */) {
+                    var texts = [getLiteralType(template.head.text)];
+                    var rawTexts = [getLiteralType(template.head.rawText)];
+                    var args = [];
                     ts.forEach(template.templateSpans, function (span) {
-                        args_3.push(span.expression);
+                        texts.push(getLiteralType(span.literal.text));
+                        rawTexts.push(getLiteralType(span.literal.rawText));
+                        args.push(span.expression);
                     });
-                }
-                return args_3;
+                    var arrayType = createTupleType(texts, undefined, true);
+                    var rawType = createTupleType(rawTexts, undefined, true);
+                    var attributesTable = ts.createSymbolTable();
+                    var attributeSymbol = createSymbol(4 /* Property */, "raw", 8 /* Readonly */);
+                    attributeSymbol.type = rawType;
+                    attributesTable.set("raw", attributeSymbol);
+                    var objectType = createAnonymousType(undefined, attributesTable, ts.emptyArray, ts.emptyArray, undefined, undefined);
+                    var stringsType = getIntersectionType([arrayType, objectType]);
+                    args.unshift(createSyntheticExpression(template, stringsType));
+                    return args;
+                }
+                return [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())];
             }
             if (node.kind === 161 /* Decorator */) {
                 return getEffectiveDecoratorArguments(node);
